#!/bin/bash
# Bash version of yona

CONFIG_DIR=${XDG_CONFIG_DIR:-$HOME/.config/yona}
YONA_FILE=".yona"
EXE_EXT=".yonax"

function initialise {
	DEFAULT_YONA_FILE='show = pwd && cat .yona'
	if [[ -z "$1" ]]; then
		echo -e $DEFAULT_YONA_FILE >> $YONA_FILE
	else
		echo -e $1 >> $YONA_FILE
	fi
}

function print_help {
	cat <<- EOF
	Yona: the script that stands in the blush of the build v0.3.0
	Usage:
	    [1myona PROJECT_COMMAND[0m
	Runs a command called PROJECT_COMMAND specified in the closest 
	"Project commands" file. This can be any one of:
	    1. A .yona file
	    2. A Makefile
	    3. A package.json
	Commands are prioritised in that order, so a "build" command in both a .yona &
	a Makefile results in the yona script being run.
	A .yona file has the format
	    COMMAND_NAME = SHELL_COMMAND
	where SHELL_COMMAND must not contain [3many[0m newlines, even with a "\".
	    [1myona [-l|--list] [DIRECTORY][0m
	Lists project commands currently available.
	    [1myona [-f|--file] [run|compile] FILE[0m
	Runs or compiles FILE according to its filetype. Checks whether an executable
	with the name part of FILE (that is, the name without extension) plus a special
	extension exists already, and if it does, executes that when asked to run FILE.
	The special extension is ".yonax" by default.
	    [1myona [-s|--shell] SHELL_COMMAND[0m
	    [1mysh SHELL_COMMAND[0m
	Runs SHELL_COMMAND at project root, i.e. whereever the nearest source of project 
	commands is.
	EOF
}


function print_version {
	echo -e "Yona of the build v0.3.0"
}


# get file extension, name, name part, & parent directory
function get_fileinfo {
	PARENT=$(dirname $1)
	NAME=$(basename $1)
	NAME_PART=${NAME%%.*}
	EXT=${NAME##*.}
}


# Does its level best to "run" the given file, whatever that may mean for that 
# file. Mostly it will just choose the right interpreter for the job (python, 
# lua, etc.), but if it finds an executable whose name is the "name part" of
# the file + $EXE_EXT, it will try to run that instead.
# Parameters:
#	$1 = The absolute path to the file
function run_file {
	source $CONFIG_DIR/run.sh
	echo -e $START_MSG
	get_fileinfo $1
	cd $PARENT
	if [[ -x "$NAME_PART$EXE_EXT" ]]; then
		./$NAME_PART$EXE_EXT
		echo -e $END_MSG
		return
	fi
	if [[ -n "${RUNNERS[$EXT]}" ]]; then
		# replace %< & % with name part & name, and then run it
		TO_RUN=${RUNNERS[$EXT]/\%\</$NAME_PART}
		TO_RUN=${TO_RUN/\%\+/$NAME_PART$EXE_EXT}
		eval "${TO_RUN/\%/$NAME}"
		echo -e $END_MSG
		return
	fi
}

# Compiles the given file with the relevant program based on the file's 
# extension.
# Parameters:
#	$1 = The absolute path to the file
function compile_file {
	source $CONFIG_DIR/compile.sh
	echo -e $START_MSG
	get_fileinfo $1
	cd $PARENT
	if [[ -n ${COMPILERS[$EXT]} ]]; then
		# replace %< & % with name part & name, and then run it
		TO_RUN=${COMPILERS[$EXT]/\%\</$NAME_PART}
		TO_RUN=${TO_RUN/\%\+/$NAME_PART$EXE_EXT}
		eval "${TO_RUN/\%/$NAME}"
		echo -e $END_MSG
		return
	fi
}

# Runs a given command at project root. Looks for the git root first, then if 
# that fails looks for a file called '.yona' in the ancestors of pwd.
# Looks for command with the name of $1 in .yona, unless that command is
# shell,sh, etc., in which case it just passes all other arguments asa
# command to bash
# Parameters:
#	$1 = name of command given in .yona file
#	${2,3,...} = arguments to pass to the command in the .yona file
function project_command {
	case $1 in
		sh | shell)
			shift 1
			eval "$@"
			return;;
		root) pwd && return;;
		*) 
			LINE=$(grep "^$1 = " $YONA_FILE)
			if [[ -z "$LINE" ]]; then
				echo -e \
					"\e[31mYona Error: Undefined project command!\e[0m" >&2
				exit 1
			fi
			eval "${LINE#*= }";;
	 esac
}

# calls the project_command function, if it can find a .yona file
function project_mode {
	PROJ_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
	START_DIR=$(pwd)
	if [[ -n "$PROJ_ROOT" ]]; then
		cd $PROJ_ROOT
		if [[ -e .yona ]]; then
			project_command $@
			return
		fi
	fi
	cd $START_DIR
	until [[ $(pwd) == / ]]; do
		if [[ -e .yona ]]; then
			project_command $@
			return
		fi
		cd ..
	done
	echo -e \
		"\e[31mYona Error: No .yona file!\e[0m" >&2
	exit 1
}


# calls the run_file or compile_file functions
function single_file_mode {
	case $1 in
		run) run_file $2;;
		compile) compile_file $2;;
		*) echo -e "Invalid file command!\nUse either run or compile.";;
	esac
}


case $1 in
	-s | --single-file) single_file_mode $2 $3;;
	-h | --help) print_help;;
	-v | --version) print_version;;
	init) initialise $2;;
	*) project_mode $@;;
esac
